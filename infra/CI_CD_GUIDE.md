# CI/CD Pipeline Guide

## GitHub Actions Workflows

### 1. Main CI/CD Pipeline (ci-cd.yml)

Runs on every push to `main` and `develop` branches.

**Jobs:**
1. **test** - Linting, unit tests, coverage
2. **build** - Docker image build and push
3. **deploy-minikube** - Deploy to local Minikube
4. **security-scan** - Trivy vulnerability scanning
5. **notify** - Slack notifications

### 2. Security Workflow (security.yml)

Runs on push, PR, and weekly schedule.

**Jobs:**
- Bandit security scan (Python security)
- Safety check (dependency vulnerabilities)

## Setup GitHub Actions

### 1. Add Secrets to GitHub

Go to your repository: **Settings → Secrets and variables → Actions**

Add these secrets:

```
GITHUB_TOKEN          # Auto-generated by GitHub
SLACK_WEBHOOK         # (Optional) Slack webhook URL
DOCKER_REGISTRY       # ghcr.io (GitHub Container Registry)
```

### 2. Configure Environment Variables

Create `.github/workflows/env.yml`:
```yaml
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
```

### 3. Enable Container Registry

```bash
# Login to Docker (local test)
docker login ghcr.io

# Push image
docker push ghcr.io/your-username/your-repo-api:latest
```

## Workflow Details

### CI/CD Workflow Steps

1. **Checkout Code**
   - Fetches latest code

2. **Test Phase**
   - Python 3.12 setup
   - Install dependencies
   - Run flake8 linting
   - Format check with black
   - Execute pytest with coverage
   - Upload coverage to codecov

3. **Build Phase** (on main/develop push)
   - Setup Docker Buildx
   - Login to container registry
   - Build FastAPI image
   - Build Streamlit image
   - Push to registry

4. **Deploy Phase** (main branch only)
   - Start Minikube
   - Build images in Minikube
   - Apply Kubernetes manifests
   - Wait for rollout
   - Run health checks

5. **Security Phase**
   - Trivy filesystem scan
   - Upload SARIF report

6. **Notify Phase**
   - Send Slack notification

## Manual Workflow Triggers

You can manually trigger workflows:

```bash
# Trigger via GitHub CLI
gh workflow run ci-cd.yml

# View workflow runs
gh run list
gh run view <run-id>
```

## Local Testing

### Test Linting Locally
```bash
pip install flake8 black isort
flake8 api_gateway agents services --max-line-length=127
black --check api_gateway agents services
```

### Test Docker Build Locally
```bash
docker build -f infra/docker/Dockerfile -t llmops-rag-api:test .
docker run -p 8000:8000 llmops-rag-api:test
```

### Test Kubernetes Deployment Locally
```bash
minikube start
bash infra/k8s/deploy.sh
```

## Image Registry

### Push to GitHub Container Registry
```bash
# Login
echo $CR_PAT | docker login ghcr.io -u USERNAME --password-stdin

# Tag image
docker tag llmops-rag-api:latest ghcr.io/your-username/your-repo-api:latest

# Push
docker push ghcr.io/your-username/your-repo-api:latest

# List images
docker search ghcr.io/your-username/your-repo
```

### Pull from Registry
```bash
docker pull ghcr.io/your-username/your-repo-api:latest
docker run -p 8000:8000 ghcr.io/your-username/your-repo-api:latest
```

## Monitoring Pipeline

### View Workflow Status
- GitHub: **Actions** tab
- GitHub CLI: `gh run list`
- Notifications: Email or Slack

### Debugging Pipeline Failures

1. **View logs**
   - Click on failed job in GitHub Actions
   - Expand failing step
   - Look for error messages

2. **Common Issues**
   - Missing secrets
   - Dependency version conflicts
   - Docker build context problems
   - Kubernetes resource conflicts

3. **Re-run workflow**
   - GitHub Actions UI: "Re-run jobs"
   - Or push a new commit

## Production Deployment

### Recommended Workflow

1. **Development branch**
   - Feature branches → PR → merge to develop
   - CI runs, but limited deployment

2. **Staging/Main branch**
   - `develop` → PR → merge to `main`
   - Full CI/CD pipeline runs
   - Deploy to Minikube/staging
   - Run full test suite

3. **Production**
   - Tag release: `v1.0.0`
   - Deploy to production cluster (EKS/GKE/AKS)
   - Update production deployment.yaml

### Example Production Deployment
```yaml
# .github/workflows/production.yml
name: Production Deploy
on:
  push:
    tags:
      - 'v*'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      # Deploy to production cluster
      - name: Deploy to EKS
        run: |
          aws eks update-kubeconfig --name prod-cluster
          kubectl set image deployment/llmops-rag-api \
            api-gateway=ghcr.io/.../api:${{ github.ref_name }}
```

## Cost Optimization

### GitHub Actions Free Tier
- 2,000 free minutes/month
- 20GB storage for artifacts & logs

### Reduce Pipeline Cost
```yaml
# Only run expensive jobs on main branch
if: github.ref == 'refs/heads/main'

# Cache dependencies
- uses: actions/cache@v3
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
```

## Best Practices

1. **Always test locally first**
2. **Use multiple environments** (dev, staging, prod)
3. **Keep secrets secure** - use GitHub secrets
4. **Run tests before merge**
5. **Keep images small** - use multi-stage builds
6. **Monitor pipeline health** - set up Slack alerts
7. **Version your deployments** - use tags
8. **Keep workflows DRY** - avoid duplication
